import Foundation

#if os(Linux)
import Glibc
#elseif os(Windows)
import WinSDK
#else
import Darwin
#endif

private func readManifestVersion(at manifestPath: String) -> String {
    guard let contents = try? String(contentsOfFile: manifestPath, encoding: .utf8) else {
        return "unknown"
    }
    let pattern = #"BOX_VERSION:\s*([A-Za-z0-9\.\-\+_]+)"#
    if let range = contents.range(of: pattern, options: .regularExpression) {
        let match = contents[range]
        if let separatorIndex = match.firstIndex(of: ":") {
            let valueStart = match.index(after: separatorIndex)
            let value = match[valueStart...].trimmingCharacters(in: .whitespacesAndNewlines)
            if !value.isEmpty {
                return String(value)
            }
        }
    }
    return "unknown"
}

private func sanitize(_ value: String) -> String {
    value
        .replacingOccurrences(of: "\\", with: "\\\\")
        .replacingOccurrences(of: "\"", with: "\\\"")
}

private func resolveHostName() -> String {
    if let envHost = ProcessInfo.processInfo.environment["HOSTNAME"], !envHost.isEmpty {
        return envHost
    }
    if let computerName = ProcessInfo.processInfo.environment["COMPUTERNAME"], !computerName.isEmpty {
        return computerName
    }
#if os(Windows)
    if let hostName = Host.current().localizedName, !hostName.isEmpty {
        return hostName
    }
    return "unknown-host"
#else
    #if os(Linux)
    let limit = Int(HOST_NAME_MAX)
    #else
    let limit = Int(MAXHOSTNAMELEN)
    #endif
    var hostnameBuffer = [CChar](repeating: 0, count: limit)
    if gethostname(&hostnameBuffer, hostnameBuffer.count) == 0 {
        let hostName = hostnameBuffer.withUnsafeBufferPointer { buffer -> String? in
            guard let base = buffer.baseAddress else { return nil }
            return String(validatingCString: base)
        }
        if let hostName, !hostName.isEmpty {
            return hostName
        }
    }
    if let hostName = Host.current().localizedName, !hostName.isEmpty {
        return hostName
    }
    return "unknown-host"
#endif
}

private func resolveUserName() -> String {
    let env = ProcessInfo.processInfo.environment
    if let user = env["USER"], !user.isEmpty {
        return user
    }
    if let user = env["USERNAME"], !user.isEmpty {
        return user
    }
    return "unknown-user"
}

private func iso8601Timestamp() -> String {
    let formatter = ISO8601DateFormatter()
    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
    return formatter.string(from: Date())
}

enum GeneratorError: Error {
    case invalidArguments
}

func main() throws {
    let arguments = CommandLine.arguments
    guard arguments.count == 3 else {
        throw GeneratorError.invalidArguments
    }
    let packageDirectory = arguments[1]
    let outputPath = arguments[2]

    let manifestPath = (packageDirectory as NSString).appendingPathComponent("Package.swift")

    let version = readManifestVersion(at: manifestPath)
    let host = resolveHostName()
    let user = resolveUserName()
    let timestamp = iso8601Timestamp()

    let contents = """
    // Generated by BoxBuildInfoPlugin. Do not edit.
    enum BoxBuildInfo {
        static let version = "\(sanitize(version))"
        static let builderHost = "\(sanitize(host))"
        static let builderUser = "\(sanitize(user))"
        static let timestamp = "\(sanitize(timestamp))"

        static var description: String {
            "\(sanitize(version)) \(sanitize(host)) \(sanitize(user)) \(sanitize(timestamp))"
        }
    }
    """

    let outputURL = URL(fileURLWithPath: outputPath)
    try FileManager.default.createDirectory(at: outputURL.deletingLastPathComponent(), withIntermediateDirectories: true)
    try contents.write(to: outputURL, atomically: true, encoding: .utf8)
}

do {
    try main()
} catch {
    if let data = "BoxBuildInfoGenerator error: \(error)\n".data(using: .utf8) {
        FileHandle.standardError.write(data)
    }
    exit(1)
}
