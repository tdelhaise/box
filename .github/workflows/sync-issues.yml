name: Sync NEXT_STEPS to Issues

on:
  push:
    paths:
      - 'NEXT_STEPS.md'
  workflow_dispatch: {}

permissions:
  contents: write
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create/update issues and back-link in NEXT_STEPS.md
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'NEXT_STEPS.md';
            const text = fs.readFileSync(path, 'utf8');

            // Parse numbered items like "1) Title" and collect following indented bullets until blank line.
            const lines = text.split(/\r?\n/);
            const items = [];
            let i = 0;
            while (i < lines.length) {
              const m = lines[i].match(/^\s*(\d+)\)\s+(.+)$/);
              if (!m) { i++; continue; }
              const idx = parseInt(m[1], 10);
              const title = m[2].replace(/\s*\(Issue #\d+\).*$/, '').trim(); // strip existing link
              const bodyLines = [];
              let j = i + 1;
              while (j < lines.length) {
                const l = lines[j];
                if (/^\s*$/.test(l)) break; // stop at blank line
                if (/^\s*-\s+/.test(l) || /^\s+-.+/.test(l)) bodyLines.push(l.trim().replace(/^\-\s+/, ''));
                j++;
              }
              items.push({ idx, title, bullets: bodyLines });
              i = j + 1;
            }

            core.info(`Parsed ${items.length} items from NEXT_STEPS.md`);

            // Get existing open issues to avoid duplicates
            const existing = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100,
            });
            const titleToIssue = new Map(existing.map(it => [it.title, it]));

            // Ensure labels exist
            const ensureLabel = async (name, color, description) => {
              try {
                await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name });
              } catch (e) {
                await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name, color, description });
              }
            };
            await ensureLabel('roadmap', '0e8a16', 'Created from NEXT_STEPS.md');
            await ensureLabel('automation', '5319e7', 'Created by sync workflow');

            // Create missing issues or update existing (add acceptance checklist)
            const ensureIssue = async (it) => {
              let issue = titleToIssue.get(it.title);
              const checklist = it.bullets && it.bullets.length ? ['\nAcceptance criteria:', ...it.bullets.map(b => `- [ ] ${b}`), ''] : [];
              if (!issue) {
                const body = [ checklist.join('\n'), 'Source: NEXT_STEPS.md (auto-synced).' ].filter(Boolean).join('\n\n');
                const created = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: it.title,
                  body,
                  labels: ['roadmap', 'automation'],
                });
                core.info(`Created issue: ${it.title}`);
                issue = created.data;
                titleToIssue.set(it.title, issue);
              } else {
                // Update body to include checklist if not present
                const hasChecklist = /\- \[ \]/.test(issue.body || '') || /Acceptance criteria:/i.test(issue.body || '');
                if (!hasChecklist && checklist.length) {
                  const newBody = [ issue.body || '', checklist.join('\n'), 'Source: NEXT_STEPS.md (auto-synced).' ].join('\n\n');
                  await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, body: newBody });
                  core.info(`Updated issue with checklist: #${issue.number}`);
                }
              }
              return issue.number;
            };

            const mapping = new Map();
            for (const it of items) {
              const num = await ensureIssue(it);
              mapping.set(it.idx, { title: it.title, number: num });
            }

            // Update NEXT_STEPS.md with issue links
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const linkFor = (n) => (mapping.get(n) ? ` (Issue #${mapping.get(n).number})` : '');
            const newLines = [];
            let k = 0;
            while (k < lines.length) {
              const m = lines[k].match(/^\s*(\d+)\)\s+(.+)$/);
              if (!m) { newLines.push(lines[k]); k++; continue; }
              const idx = parseInt(m[1], 10);
              const title = m[2].replace(/\s*\(Issue #\d+\).*$/, '').trim();
              const suffix = linkFor(idx);
              newLines.push(`${idx}) ${title}${suffix}`);
              k++;
            }

            const newText = newLines.join('\n');
            if (newText !== text) {
              const getRes = await github.rest.repos.getContent({ owner, repo, path });
              const sha = Array.isArray(getRes.data) ? null : getRes.data.sha;
              await github.rest.repos.createOrUpdateFileContents({
                owner, repo, path,
                message: 'chore: back-link NEXT_STEPS to created issues (auto)',
                content: Buffer.from(newText, 'utf8').toString('base64'),
                sha,
              });
              core.info('Updated NEXT_STEPS.md with issue links');
            } else {
              core.info('No changes to NEXT_STEPS.md');
            }
